# ADR: 接続タイムアウト管理における共通 Heartbeat Loop 採用

# Status
- Deprecated: 内容が古くなり破棄された

# Decision
接続のタイムアウトには接続全てを管理する共通heartbeat loopを作成し、タイムアウトを管理する。
大規模接続の際に、メモリ使用量が爆発するのが懸念されたため。

# Context
Server層において接続してくる接続のタイムアウトをどう管理するのかを決定する必要があった。
- 接続ごとに管理する。
- 全体として管理する

# Consideration
比較軸として以下を設定
- pros/cons
- スケーラビリティ
- レイテンシ
- リソース量
- タイムアウト精度
- カスタマイズ性
- 運用性
- 好み

### 比較軸での整理
- pros/cons
  - 接続ごと: 実装が直感的で精度も高いが、接続数に比例して goroutine/タイマーが増える。
  - 全体: goroutine 数が抑えられリソース上限を見積もりやすいが、スキャン処理が複雑。
- スケーラビリティ
  - 接続ごと: O(N) で goroutine が増え、大規模で負荷になりやすい。
  - 全体: goroutine は少数で済むが、Tick ごとの線形スキャンで CPU バーストの可能性。
- レイテンシ
  - 接続ごと: タイムアウト検知が即時に近く、切断遅延が少ない。
  - 全体: Tick 粒度に依存し、切断が遅れがち。
- リソース量
  - 接続ごと: メモリは goroutine/タイマー分増加。CPU も接続に比例。
  - 全体: goroutine/タイマーは少ない一方、スキャンの CPU が増減する。
- タイムアウト精度
  - 接続ごと: ミリ秒〜秒単位で細かく設定しやすい。
  - 全体: Tick 間隔が下限となり、精度が粗くなる。
- カスタマイズ性
  - 接続ごと: セッション生成時に per-conn 設定を持たせやすい。
  - 全体: スキャン時に per-conn 設定を見る必要があり、データ構造が複雑化する。
- 運用性
  - 接続ごと: 観測はしやすいが、goroutine リークに注意。
  - 全体: ロックや分割（シャーディング）設計が必要だが、リソース上限は管理しやすい。
- 好み
  - 接続ごと: シンプルさ優先ならこちら。
  - 全体: スケール優先・リソース上限管理重視ならこちら。

# References
- [ADR-002: Per-Connection Owner Loop による接続管理設計](./ADR-002-per-connection-management.md) によって破棄
